<!doctype html>
<html lang="en-us">
  <head>
    <title>Big-O // KONPIG BLOG</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.73.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Kim Youlim" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.e1e8cabbc19bd42bb8f3f352564bf4c21cad42c23451f3d9b5d6000fea30d504.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Big-O"/>
<meta name="twitter:description" content="Big-O 표기법이란 알고리즘의 효율성을 나타내는 지표 혹은 언어를 말한다.
보통 알고리즘의 시간복잡도와 공간복잡도를 나타낼 때 사용한다.
  시간복잡도 : 알고리즘의 시간 효율성
  공간복잡도 : 알고리즘의 공간(메모리) 효율성
- 크기가 N인 배열을 만들고자 한다면 공간복잡도는 O(N)
- 크기가 N*N인 2차원 배열을 만들고자 한다면 공간복잡도는 O(N^2)
- 공간복잡도 계산 시 재귀호출에서 사용하는 스택공간을 포함하여 계산해야한다.
   비교 그래프 자주 사용하는 Big-O 표기법을 효율성이 좋은 것 부터 나열해보자면 아래와 같다."/>

    <meta property="og:title" content="Big-O" />
<meta property="og:description" content="Big-O 표기법이란 알고리즘의 효율성을 나타내는 지표 혹은 언어를 말한다.
보통 알고리즘의 시간복잡도와 공간복잡도를 나타낼 때 사용한다.
  시간복잡도 : 알고리즘의 시간 효율성
  공간복잡도 : 알고리즘의 공간(메모리) 효율성
- 크기가 N인 배열을 만들고자 한다면 공간복잡도는 O(N)
- 크기가 N*N인 2차원 배열을 만들고자 한다면 공간복잡도는 O(N^2)
- 공간복잡도 계산 시 재귀호출에서 사용하는 스택공간을 포함하여 계산해야한다.
   비교 그래프 자주 사용하는 Big-O 표기법을 효율성이 좋은 것 부터 나열해보자면 아래와 같다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/big-o/" />
<meta property="article:published_time" content="2020-07-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-07-14T00:00:00+00:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="/"><img class="app-header-avatar" src="/avatar.jpg" alt="Kim Youlim" /></a>
      <h1>KONPIG BLOG</h1>
      <p>Welcome</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/kimkonpig" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Big-O</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          July 14, 2020
        </div>
        </div>
    </header>
    <div class="post-content">
      <h1 id="--big-o--"><!-- raw HTML omitted --></h1>
<p><strong>Big-O</strong> 표기법이란 알고리즘의 효율성을 나타내는 지표 혹은 언어를 말한다.</p>
<p>보통 알고리즘의 시간복잡도와 공간복잡도를 나타낼 때 사용한다.</p>
<ul>
<li>
<p>시간복잡도 : 알고리즘의 시간 효율성</p>
</li>
<li>
<p>공간복잡도 : 알고리즘의 공간(메모리) 효율성</p>
<p><code>-</code> 크기가 N인 배열을 만들고자 한다면 공간복잡도는 O(N)</p>
<p><code>-</code> 크기가 N*N인 2차원 배열을 만들고자 한다면 공간복잡도는 O(N^2)</p>
<p><code>-</code> 공간복잡도 계산 시 재귀호출에서 사용하는 스택공간을 포함하여 계산해야한다.</p>
</li>
</ul>
<hr>
<h2 id="비교-그래프">비교 그래프</h2>
<p>자주 사용하는 Big-O 표기법을 효율성이 좋은 것 부터 나열해보자면 아래와 같다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">O<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> &lt; O<span style="color:#f92672">(</span>logN<span style="color:#f92672">)</span> &lt; O<span style="color:#f92672">(</span>N<span style="color:#f92672">)</span> &lt; O<span style="color:#f92672">(</span>NlogN<span style="color:#f92672">)</span> &lt; O<span style="color:#f92672">(</span>N^2<span style="color:#f92672">)</span> &lt; O<span style="color:#f92672">(</span>2N<span style="color:#f92672">)</span> &lt; O<span style="color:#f92672">(</span>N!<span style="color:#f92672">)</span> &lt; O<span style="color:#f92672">(</span>N^N<span style="color:#f92672">)</span>
</code></pre></div><p><img src="/img/20200714-01.JPG" alt="graph"></p>
<p>(아이패드 첫 사용 기념으로 애플펜슬로 그려봤는데 발로 그린 게 더 낫겠다.)</p>
<h2 id="최선-최악-평균">최선, 최악, 평균</h2>
<p>하나의 알고리즘에서 최선, 최악, 평균 시간을 구할 수 있다.</p>
<p>퀵정렬을 예로 들어 간단히 설명하자면, N을 배열의 크기라고 가정했을 때</p>
<ul>
<li>
<p>최선 : 모든 원소들이 같은 값일 때 시간복잡도 -&gt; <strong>O(N)</strong></p>
</li>
<li>
<p>최악 : 배열의 가장 큰 원소가 계속 축이 될 때 시간복잡도 -&gt; <strong>O(N^2)</strong></p>
<p><code>-</code> 배열을 절반으로 나누지 못하고 계속 한 개씩만 줄어든 배열로 리턴</p>
</li>
<li>
<p>평균 : 배열을 절반으로 나누어 정렬할 때 시간복잡도 -&gt; <strong>O(NlogN)</strong></p>
</li>
</ul>
<p><em>퀵정렬이란?</em></p>
<p><em>축이 되는 원소를 무작위로 하나 정하여 축보다 작은 원소들은 앞으로, 큰 원소들은 뒤로 놓이도록 Swap을 반복하여 정렬하는 방법</em></p>
<h2 id="특징-1---사소한-부분-무시">특징 1 - 사소한 부분 무시</h2>
<p>Big-O는 효율성의 비율을 나타내는 개념으로 입력값이 충분히 크다고 가정한다.</p>
<p>따라서 사소한 부분(계산에 큰 영향을 미치지 않는)은 무시할 수 있다.</p>
<ul>
<li>
<p>상수항 무시
O(2N) -&gt; O(N)</p>
</li>
<li>
<p>수식에서 지배적이지 않은 항 무시
O(N^2 + N) -&gt; O(N^2)
O(N + logN) -&gt; O(N)
O(5*2^N + 1000N^100) -&gt; O(2^N)</p>
</li>
</ul>
<h2 id="특징-2---덧셈--곱셈-수행시간">특징 2 - 덧셈 / 곱셈 수행시간</h2>
<p>실행순서에 따라 수행시간 계산 방식이 달라진다.</p>
<ul>
<li>
<p>O(A + B) : A를 끝마친 후에 B 수행</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">:</span> arrA<span style="color:#f92672">){</span>
    print<span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
  
<span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">:</span> arrB<span style="color:#f92672">){</span>
    print<span style="color:#f92672">(</span>b<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>O(A * B) : A가 할 때마다 B 수행</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">:</span> arrA<span style="color:#f92672">){</span>
  <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">:</span> arrB<span style="color:#f92672">){</span>
      print<span style="color:#f92672">(</span>a <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">+</span> b<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h2 id="logn-수행시간">logN 수행시간</h2>
<p><strong>O(logN)</strong> : 이진탐색, 균형 이진탐색트리 사용 시 확인할 수 있다.</p>
<ul>
<li>
<p>탐색 과정</p>
<ol>
<li>
<p>원소 x와 배열의 중간값 m을 비교</p>
</li>
<li>
<p>x==m 일 때 반환 또는 x&lt;m 일 때 배열의 왼쪽 부분 재탐색</p>
</li>
</ol>
</li>
<li>
<p>처음 N개에서 한 단계씩 거치면서 탐색할 원소의 개수가 N/2, N/4, &hellip; 로 줄어든다.</p>
<p>따라서 총 수행시간은 N을 절반씩 나누는 과정에서 몇 단계만에 1이 되는지에 따라 결정된다.</p>
</li>
<li>
<p>N이 16일 때 16에서 1로 감소하는 순서를 뒤집어서 1에서 16으로 증가하는 순서로 생각해보면,</p>
<p>숫자 1에 2를 4번 곱해야 N이 된다. 즉, 2^k = N을 만족하는 k를 구할 때 사용되는 것이 log이다.</p>
</li>
</ul>
<p><em>이진탐색이란? N개의 정렬된 원소가 들어있는 배열에서 원소 x를 찾을 때 사용하는 방법이다.</em></p>
<h2 id="재귀호출-수행시간">재귀호출 수행시간</h2>
<ul>
<li>
<p>깊이가 N인 이진트리(각 노드는 두개의 자식 노드를 가진다.)를 예시로 들면, O(분기^깊이) -&gt; O(2^깊이) -&gt; <strong>O(2^N)</strong></p>
</li>
<li>
<p>깊이가 한 단계 깊어질 때마다 재귀호출은 2배씩 많아진다.</p>
</li>
</ul>
<h2 id="참고---2의-승수의-합">참고 - 2의 승수의 합</h2>
<p><em>깊이가 N인 트리의 전체 노드의 개수 = <strong>2의 승수의 합</strong> = ( 2^(N+1) - 1 )</em></p>
<ul>
<li>
<p>2의 승수의 합 : 2^0 + 2^1 + 2^2 + &hellip; + 2^n 의 결과는?</p>
<table>
<thead>
<tr>
<th align="center">승수</th>
<th align="center">2진수</th>
<th align="center">10진수</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">2^0</td>
<td align="center">00001</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2^1</td>
<td align="center">00010</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">2^2</td>
<td align="center">00100</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">2^3</td>
<td align="center">01000</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">2^4</td>
<td align="center">10000</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">합 = 2^5 -1</td>
<td align="center">11111</td>
<td align="center">32-1 = 31</td>
</tr>
</tbody>
</table>
<p>따라서 수열의 연산을 2진수로 표현하면 1이 연속으로 (n+1) 개 나열된 값과 같다. 이는 2^n+1 -1과 같다.</p>
</li>
</ul>
<h2 id="참고자료">참고자료</h2>
<p>게일 라크만 맥도웰, 코딩 인터뷰 완전 분석, 인사이트, 2017</p>

    </div>
    <div class="post-footer">
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "kimkonpig" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </article>

    </main>
  </body>
</html>
